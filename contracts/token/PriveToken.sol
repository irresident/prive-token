pragma solidity 0.4.24;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
import "openzeppelin-solidity/contracts/ownership/Whitelist.sol";
import "./IToken.sol";
import "./ICrowdsale.sol";
import "./IRoyaltyBearingToken.sol";
import "../copyright/PriveCopyright.sol";


/**
 * @title PriveToken
 * @author Irresident Limited - www.irresident.io
 * @notice Prive Token is a smart contract for tracking copyright ownership among Prive copyright holders.
 */
contract PriveToken is IToken, Ownable, DetailedERC20, StandardToken, Whitelist, PriveCopyright, IRoyaltyBearingToken {
    using SafeMath for uint256;

    // Address of the crowdsale used to distribute this token
    address public crowdsale;
    // Entity that issued this asset
    string public issuer;
    // Asset type
    string public assetType;
    // Type of income generated by this asset
    string public incomeType;
    // Whether the token is fungible
    bool public fungible;
    // Tokens are not initially tradable until enabled for trading, then they are tradable forever
    bool public tradable;
    // Maximum amount of tokens that can be minted
    uint256 internal maximumSupply_;
    // Amount of tokens minted through sale by crowdsale(s)
    uint256 internal soldSupply_;
    // Maximum amount of tokens that can be sold
    uint256 public crowdsaleCap;
    // Royalty Mechanism
    address public royaltyMechanism;
    // Maximum number of royalty distribution rounds for which interest claims are stored. Earlier round data is
    // discarded.
    uint8 public constant MAX_ROYALTY_DISTRIBUTION_ROUNDS = 3;
    // Id of the latest royalty distribution round id for which interest claims are stored; 0 if there is no round
    uint256 private _latestRoyaltyDistributionRound;

    // Structure holding claimed interest for a royalty distribution round expressed as a scalar value matching the
    // amount of Prive tokens instead of a percentage
    struct ClaimedRoyaltyInterest {
        uint256 round;    // id of the royalty distribution round
        uint256 amount;     // amount of claimed royalty interest
    }

    // Claimed royalty distribution round interest per token holder
    mapping(address => ClaimedRoyaltyInterest[3]) private _claimedRoyaltyInterest;

    // Sum total of claimed royalty distribution round interest for all holders
    ClaimedRoyaltyInterest[3] private _totalClaimedRoyaltyInterest;


    /**
     * @notice Event for token mint logging.
     * @param to address token was minted to
     * @param amount amount of tokens minted
     */
    event Mint(address indexed to, uint256 amount);

    /**
     * @notice Event triggered every time crowdsale is changed.
     * @param previousCrowdsale address of the previous crowdsale or 0 if none was set
     * @param newCrowdsale address of the new crowdsale or 0 if none was set
     */
    event CrowdsaleChanged(address indexed previousCrowdsale, address indexed newCrowdsale);

    /**
     * @notice Event triggered every time crowdsale cap is set.
     * @param oldCap previous crowdsale cap
     * @param newCap new crowdsale cap
     */
    event CrowdsaleCapChanged(uint256 oldCap, uint256 newCap);

    /**
     * @notice Event triggered when trading is enabled. This can occur only once since once enabled, trading is enabled
     * forever.
     */
    event TradingEnabled();


    /**
     * @notice Event triggered when royalty mechanism is changed.
     * @param previousMechanism address of the previous royalty mechanism or 0 if none was set
     * @param newMechanism address of the new mechanism or 0 if none is set
     */
    event RoyaltyMechanismChanged(address indexed previousMechanism, address indexed newMechanism);

    /**
     * @notice Event for start of a new royalty distribution round logging.
     * @param round id of the round that started
     */
    event NewRoyaltyDistributionRoundStarted(uint256 indexed round);

    /**
     * @notice Event for claiming unpaid royalty interest logging.
     * @param holder the address claiming royalty interest
     * @param round id of the royalty round for which interest was claimed
     * @param claimedInterest how much unclaimed royalty interest was claimed
     * @param holderTotalClaimedInterest sum total of all claimed royalty interest for holder in the round
     * @param totalClaimedInterest sum total of all claimed royalty interest in the round
     */
    event RoyaltyInterestClaimed(
        address indexed holder, uint256 indexed round, uint256 claimedInterest,
        uint256 holderTotalClaimedInterest, uint256 totalClaimedInterest
    );

    /**
     * @notice Event for logging of transfer of claimed royalty interest when token ownership is transferred.
     * @param from token holder from whom claimed interest is transferred
     * @param to token holder to whom claimed interest is transferred
     * @param round id of the round for which claimed royalty interest was transferred for
     * @param amount amount of claimed interest that has been transferred
     */
    event ClaimedRoyaltyInterestTransferred(address indexed from, address indexed to, uint256 round, uint256 amount);

    constructor(LegalProse _legalProse) public
        DetailedERC20("Privé Token", "PRIVE", 18)
        PriveCopyright(_legalProse)
    { // solhint-disable-line bracket-align
        maximumSupply_ = 50000000 * 1 ether;
        crowdsale = address(0);
        royaltyMechanism = address(0);
        issuer = "Privé Trust";
        assetType = "Copyright";
        incomeType = "Royalties";
        fungible = true;
        tradable = false;
        soldSupply_ = 0;
        crowdsaleCap = 0;
        _latestRoyaltyDistributionRound = 0;
    }

    /**
     * @notice Total number of tokens that have been minted and sold by crowdsale(s).
     * @return Amount of tokens minted through sale by crowdsale(s)
     */
    function soldSupply() public view returns (uint256) {
        return soldSupply_;
    }

    /**
     * @notice Maximum amount of tokens that can be minted.
     * @return maximum number of tokens that can be minted
     */
    function maximumSupply() public view returns(uint256) {
        return maximumSupply_;
    }

    /**
     * @notice Returns the amount of tokens distributed through means other than selling them.
     * @return the amount of tokens distributed through means other than sale
     */
    function usedPrivateSupply() public view returns(uint256) {
        return totalSupply_.sub(soldSupply_);
    }

    /**
     * @notice Returns the amount of tokens reserved for private use.
     * @return the number of tokens reserved for private use
     */
    function availablePrivateSupply() public view returns(uint256) {
        return maximumSupply_.sub(crowdsaleCap).sub(usedPrivateSupply());
    }

    /**
     * @notice Returns balance and timestamp of copyright agreement for given address.
     * @param _for client address to look up
     * @return Tuple with balance and copyright agreement timestamp or 0 if client has not agreed.
     */
    function balanceAndAgreement(address _for) public view returns (uint256 balance, uint256 agreementTimestamp) {
        balance = balances[_for];
        agreementTimestamp = acceptedAgreements[_for];
    }

    /**
     * @notice Validates that destination address for token transactions isn't token or crowdsale contract.
     */
    modifier validAddress(address _to) {
        require(_to != address(0));     // prevent sending tokens to 0x0 address aka nowhere
        require(_to != address(this));  // prevent sending tokens to token itself
        require(_to != crowdsale);      // prevent sending tokens to crowdsale contract
        _;
    }

    /**
     * @notice Validates that only calls coming from crowdsale have access
     */
    modifier onlyCrowdsale() {
        require(crowdsale != address(0) && msg.sender == crowdsale);
        _;
    }

    /**
     * @notice Allows the current owner to change address of the crowdsale contract and triggers CrowdsaleChanged event.
     * @param _crowdsale the address to set for the crowdsale.
     * @param _force forces the previous crowdsale deactivation by not call deactivation function on it
     */
    function setCrowdsale(address _crowdsale, bool _force) external onlyOwner {
        address prevCrowdsale = crowdsale;
        uint256 prevCap = crowdsaleCap;
        crowdsale = address(0);
        crowdsaleCap = soldSupply_;

        if (prevCrowdsale != address(0) && !_force) {
            ICrowdsale(prevCrowdsale).deactivate();
        }
        if (_crowdsale != address(0)) {
            uint256 newCap = ICrowdsale(_crowdsale).activate(soldSupply_, totalSupply_);
            _validateCrowdsaleCap(newCap);
            crowdsale = _crowdsale;
            crowdsaleCap = newCap;
        }
        emit CrowdsaleChanged(prevCrowdsale, _crowdsale);
        emit CrowdsaleCapChanged(prevCap, crowdsaleCap);
    }

    /*
     * @dev Validates if value is within valid range for crowdsale cap. If not, it throws.
     * @param amount value to validate
     */
    function _validateCrowdsaleCap(uint256 _amount) internal view {
        require(_amount >= soldSupply_);
        require(_amount <= maximumSupply_.sub(totalSupply_).add(soldSupply_)); // cap includes sold supply so this is ok
    }

    /**
     * @notice Sets the maximum amount of tokens that can be sold by currently active crowdsale. The remaining tokens
     * up to maximum supply can be freely minted.
     * @dev Throws if called by non-crowdsale
     * @param _amount crowdsale cap amount
     */
    function setCrowdsaleCap(uint256 _amount) external onlyCrowdsale {
        _validateCrowdsaleCap(_amount);
        uint256 oldCap = crowdsaleCap;
        crowdsaleCap = _amount;
        emit CrowdsaleCapChanged(oldCap, _amount);
    }

    /**
     * @notice Function to mint tokens up to a defined cap and triggers Mint and Transfer events.
     * @param _to The address that will receive the minted tokens.
     * @param _amount The amount of tokens to mint.
     * @return A boolean that indicates if the operation was successful.
     */
    // solhint-disable-next-line no-simple-event-func-name
    function mint(address _to, uint256 _amount) external validAddress(_to) returns (bool) {
        if (crowdsale != address(0) && msg.sender == crowdsale) {
            require(crowdsaleCap.sub(soldSupply_) >= _amount);
            soldSupply_ = soldSupply_.add(_amount);
        } else {
            require(msg.sender == owner);
            // max - cap - (total - sold) = tokens free to mint outside of cap
            require(availablePrivateSupply() >= _amount);
        }
        totalSupply_ = totalSupply_.add(_amount);
        assert(totalSupply_ <= maximumSupply_);
        balances[_to] = balances[_to].add(_amount);
        emit Mint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    /**
     * @dev Throws if caller is not royalty mechanism or royalty mechanism address is not set.
     */
    modifier onlyRoyaltyMechanism() {
        require(royaltyMechanism != address(0) && msg.sender == royaltyMechanism);
        _;
    }

    /**
     * @notice Set royalty mechanism address.
     * @dev Throws if called by anything other than owner.
     * @param _royaltyMechanism address of the royalty mechanism
     */
    function setRoyaltyMechanism(address _royaltyMechanism) external onlyOwner {
        address oldMechanism = royaltyMechanism;
        royaltyMechanism = _royaltyMechanism;
        emit RoyaltyMechanismChanged(oldMechanism, _royaltyMechanism);
    }

    /**
     * @notice Returns number of royalty distribution rounds for which interest claim data is available.
     * @return number of royalty distribution rounds with available interest claim data; can be 0 to
     *         MAX_ROYALTY_DISTRIBUTION_ROUNDS
     */
    function royaltyDistributionRounds() public view returns(uint8) {
        if (_latestRoyaltyDistributionRound == 0) {
            return 0;
        }
        if (_latestRoyaltyDistributionRound < MAX_ROYALTY_DISTRIBUTION_ROUNDS) {
            return uint8(_latestRoyaltyDistributionRound);
        }
        return MAX_ROYALTY_DISTRIBUTION_ROUNDS;
    }

    /**
     * @notice Returns id of the earliest royalty distribution round id for which interest claims are stored.
     * @notice Royalty distribution rounds older than this one are considered expired and their interest claim data is
     *         discarded.
     * @return id of the earliest stored royalty distribution round or 0 if there are no rounds
     */
    function earliestRoyaltyDistributionRound() public view returns(uint256) {
        if (_latestRoyaltyDistributionRound == 0) {
            return 0;
        }
        if (_latestRoyaltyDistributionRound < MAX_ROYALTY_DISTRIBUTION_ROUNDS) {
            return 1;
        }
        return _latestRoyaltyDistributionRound.add(1).sub(MAX_ROYALTY_DISTRIBUTION_ROUNDS);
    }

    /**
     * @notice Returns id of the latest royalty distribution round id for which interest claims are stored.
     * @return id of the latest stored royalty distribution round or 0 if there are no rounds
     */
    function latestRoyaltyDistributionRound() public view returns(uint256) {
        return _latestRoyaltyDistributionRound;
    }

    /**
     * @dev Starts a new royalty distribution round.
     * @dev Throws if called by anything other than royalty mechanism.
     * @return id of the new round
     */
    function startNewRoyaltyDistributionRound() external onlyRoyaltyMechanism returns(uint256) {
        _latestRoyaltyDistributionRound = _latestRoyaltyDistributionRound.add(1);
        emit NewRoyaltyDistributionRoundStarted(_latestRoyaltyDistributionRound);
        return _latestRoyaltyDistributionRound;
    }

    /**
     * @dev Returns the index into claimedInterest array for a give royalty round id.
     * @param _royaltyRound id of the round
     * @return index into internal array for the given round id
     */
    function _getRoyaltyRoundIndex(uint256 _royaltyRound) internal pure returns(uint8) {
        // royalty round ids start at 1, so subtract to make it 0 based instead of 1
        uint256 i = _royaltyRound.sub(1) % MAX_ROYALTY_DISTRIBUTION_ROUNDS;
        return uint8(i);
    }

    /**
     * @dev Returns the claimed royalty interest record for given holder and royalty distribution round id.
     * @dev Multiple round ids share the same record, but only the latest is recorded, so id in the record might not
     *      match the id requesting it.
     * @param _holder address of the token holder
     * @param _round id of the royalty distribution round
     * @return _recordRound id of the royalty distribution round
     * @return _claimedInterest amount of claimed royalty interest for given holder and recorded round id
     */
    function _getRoyaltyRoundRecord(address _holder, uint256 _round) internal view returns(
        uint256 _recordRound, uint256 _claimedInterest
    ) {
        ClaimedRoyaltyInterest storage interestRecord = _claimedRoyaltyInterest[_holder][_getRoyaltyRoundIndex(_round)];
        _recordRound = interestRecord.round;
        _claimedInterest = interestRecord.amount;
    }

    /**
     * @notice Returns sum of royalties claimed across all holder's for a given round.
     * @notice It will throw if _round is 0.
     * @param _round id of the royalty distribution round
     * @return sum of royalty interest that has been claimed across all holders or 0 if none
     */
    function getTotalClaimedRoyaltiesForRound(uint256 _round) public view returns(
        uint256 _claimedInterest, bool _hasRecord
    ) {
        require(_round > 0);
        ClaimedRoyaltyInterest storage interestRecord = _totalClaimedRoyaltyInterest[_getRoyaltyRoundIndex(_round)];
        if (interestRecord.round != _round) {
            _claimedInterest = 0;
            _hasRecord = false;
        } else {
            _claimedInterest = interestRecord.amount;
            _hasRecord = true;
        }
    }

    /**
     * @notice Returns sum total of all claimed royalty interest across all holders for all tracked royalty
     *         distribution rounds: from earliestRoyaltyDistributionRound to latestRoyaltyDistributionRound.
     * @return _count count of tracked royalty distribution rounds (0 to MAX_ROYALTY_DISTRIBUTION_ROUNDS)
     * @return _claimedInterest total claimed royalty interest for last _count royalty distribution rounds
     *         across all holders
     * @return _round ids for _count royalty distribution rounds that _claimedInterest is for
     */
    function getTotalClaimedRoyalties() external view returns(
        uint8 _count, uint256[3] _claimedInterest, uint256[3] _round
    ) {
        _count = royaltyDistributionRounds();
        if (_count <= 0) {
            return; // no rounds
        }
        uint256 earliestRound = earliestRoyaltyDistributionRound();
        for (uint256 i = 0; i < _count; i++) {
            uint256 round = earliestRound.add(i);
            _round[i] = round;
            (_claimedInterest[i], ) = getTotalClaimedRoyaltiesForRound(round);
        }
    }

    /**
     * @notice Returns holder's claimed royalty interest for given royalty distribution round id.
     * @notice It will throw if _round is 0.
     * @param _holder address of the token holder
     * @param _round id of the royalty distribution round
     * @return _claimedInterest amount of royalty interest that has been claimed in given round or 0 if none
     * @return _hasRecord true if there is a record for royalty distribution round or false otherwise
     */
    function getClaimedRoyaltiesForRound(address _holder, uint256 _round) public view validAddress(_holder) returns(
        uint256 _claimedInterest, bool _hasRecord
    ) {
        require(_round > 0);
        uint256 recordRound;
        (recordRound, _claimedInterest) = _getRoyaltyRoundRecord(_holder, _round);
        if (recordRound != _round) {
            _claimedInterest = 0;
            _hasRecord = false;
        } else {
            _hasRecord = true;
        }
    }

    /**
     * @notice Returns holder's claimed royalty interest for all tracked royalty distribution rounds: from
     *         earliestRoyaltyDistributionRound to latestRoyaltyDistributionRound.
     * @return _count count of tracked royalty distribution rounds (0 to MAX_ROYALTY_DISTRIBUTION_ROUNDS)
     * @return _claimedInterest claimed royalty interest for last _count royalty distribution rounds
     * @return _round ids for _count royalty distribution rounds that _claimedInterest is for
     */
    function getClaimedRoyalties(address _holder) external view validAddress(_holder) returns(
        uint8 _count, uint256[3] _claimedInterest, uint256[3] _round
    ) {
        _count = royaltyDistributionRounds();
        if (_count <= 0) {
            return; // no rounds
        }
        uint256 earliestRound = earliestRoyaltyDistributionRound();
        for (uint256 i = 0; i < _count; i++) {
            uint256 round = earliestRound.add(i);
            _round[i] = round;
            (_claimedInterest[i], ) = getClaimedRoyaltiesForRound(_holder, round);
        }
    }

    /**
     * @notice Returns any unclaimed royalty interest and balance for holder and royalty distribution round id.
     * @param _holder address of the token holder
     * @param _round id of the royalty distribution round
     * @return _availableInterest amount of royalty interest that is available to be claimed or 0 if none
     * @return _hasRecord true if there is a record for royalty distribution round or false otherwise
     * @return _balance token holder's Prive token balance
     */
    function _getAvailableRoyaltiesAndBalanceFor(address _holder, uint256 _round) internal view returns(
        uint256 _availableInterest, bool _hasRecord, uint256 _balance
    ) {
        _balance = balanceOf(_holder);
        (uint256 interestRecordRound, uint256 interestRecordAmount) = _getRoyaltyRoundRecord(_holder, _round);
        if (interestRecordRound > _round) {
            // royalty round record is for a later round, so _round has expired and there is nothing to claim
            _availableInterest = 0;
            _hasRecord = false;
            return;
        }
        uint256 claimedAmount = 0;
        if (interestRecordRound == _round) {
            // record is for _round
            claimedAmount = interestRecordAmount;
            _hasRecord = true;
        } else {
            // record is uninitialized or the request round has not occurred yet
            _hasRecord = false;
        }
        if (_balance > claimedAmount) {
            _availableInterest = _balance.sub(claimedAmount);
        } else {
            _availableInterest = 0;
        }
    }

    /**
     * @notice Returns any available royalty interest for holder and royalty distribution round id.
     * @notice It will throw if _round is 0.
     * @param _holder address of the token holder
     * @param _round id of the royalty distribution round
     * @return _availableInterest amount of royalty interest that is available to be claimed or 0 if none
     * @return _hasRecord true if there is a record for royalty distribution round or false otherwise
     */
    function getAvailableRoyaltiesForRound(address _holder, uint256 _round) public view validAddress(_holder) returns(
        uint256 _availableInterest, bool _hasRecord
    ) {
        require(_round > 0);
        (_availableInterest, _hasRecord, ) = _getAvailableRoyaltiesAndBalanceFor(_holder, _round);
    }

    /**
     * @notice Returns available royalty interest for holder across all tracked royalty distribution rounds: from
     *         earliestRoyaltyDistributionRound to latestRoyaltyDistributionRound.
     * @return _count count of tracked royalty distribution rounds (0 to MAX_ROYALTY_DISTRIBUTION_ROUNDS)
     * @return _availableInterest royalty interest for last _count royalty distribution rounds that is available for
     *         claiming
     * @return _round ids for _count royalty distribution rounds that _unclaimedInterest is claimed for
     */
    function getAvailableRoyalties(address _holder) external view validAddress(_holder) returns(
        uint8 _count, uint256[3] _availableInterest, uint256[3] _round
    ) {
        _count = royaltyDistributionRounds();
        if (_count <= 0) {
            return; // no rounds
        }
        uint256 earliestRound = earliestRoyaltyDistributionRound();
        for (uint256 i = 0; i < _count; i++) {
            uint256 round = earliestRound.add(i);
            _round[i] = round;
            (_availableInterest[i], ) = getAvailableRoyaltiesForRound(_holder, round);
        }
    }

    /**
     * @notice Checks if token holder can claim their royalties.
     * @param _holder address of the token holder
     * @return true if token holder has accepted the copyright agreement, false otherwise
     */
    function canClaimRoyalties(address _holder) public view returns(bool) {
        return acceptedAgreements[_holder] > 0;
    }

    /**
     * @dev Claims and returns any unclaimed royalty interest for holder and royalty distribution round id.
     * @param _holder address of the token holder for whom royalty interest is claimed
     * @param _round id of the royalty distribution round for which interest is claimed
     * @return amount of royalty interest that has been claimed or 0 if none
     */
    function _updateRoyaltyClaim(address _holder, uint256 _round) private returns(uint256) {
        (uint256 availableInterest, bool hasRecord, uint256 holderBalance) =
            _getAvailableRoyaltiesAndBalanceFor(_holder, _round);
        if (availableInterest <= 0) {
            return 0;
        }
        uint8 index = _getRoyaltyRoundIndex(_round);
        if (!hasRecord) {
            // initialize record
            _claimedRoyaltyInterest[_holder][index].round = _round;
        }
        // update amount - holderBalance is equal to the sum of availableInterest + claimed interest, and this costs
        // less gas and claims all availableInterest as it should.
        _claimedRoyaltyInterest[_holder][index].amount = holderBalance;
        // update totals
        ClaimedRoyaltyInterest storage totals = _totalClaimedRoyaltyInterest[index];
        if (totals.round == _round) {
            // update totals
            totals.amount = totals.amount.add(availableInterest);
        } else {
            // reset totals
            totals.round = _round;
            totals.amount = availableInterest;
        }
        emit RoyaltyInterestClaimed(_holder, _round, availableInterest, holderBalance, totals.amount);
        return availableInterest;
    }

    /**
     * @dev Claims and returns holder's unclaimed royalty interest for all tracked royalty distribution rounds: from
     *      earliestRoyaltyDistributionRound to latestRoyaltyDistributionRound.
     * @dev Throws if called by anything other than royalty mechanism.
     * @dev Throws if holder is not vested i.e. has not accepted license agreement
     * @dev Throws if there are not active rounds i.e. latestRoyaltyDistributionRound is 0.
     * @param _holder address of the token holder for whom royalty interest is claimed
     * @return _count count of tracked royalty distribution rounds (0 to MAX_ROYALTY_DISTRIBUTION_ROUNDS)
     * @return _newInterest royalty interest for last _count royalty distribution rounds that have just been claimed
     */
    function accountForRoyaltyClaim(address _holder) external onlyRoyaltyMechanism validAddress(_holder) returns(
        uint8 _count, uint256[3] _newInterest
    ) {
        require(canClaimRoyalties(_holder));
        _count = royaltyDistributionRounds();
        require(_count > 0);
        uint256 earliestRound = earliestRoyaltyDistributionRound();
        for (uint256 i = 0; i < _count; i++) {
            _newInterest[i] = _updateRoyaltyClaim(_holder, earliestRound.add(i));
        }
    }


    /**
     * @dev Allow trading - called only once to enable trading forever.
     */
    function enableTrading() external onlyOwner {
        require(tradable == false);
        tradable = true;
        emit TradingEnabled();
    }

    /**
     * @dev Throws if called when token is not tradable.
     * @dev Only addresses on whitelist can trade.
     */
    modifier canTrade() {
        require(tradable || whitelist[msg.sender]);
        _;
    }

    /**
     * @dev Transfers claimed royalty interest from one token owner ot another across all tracked rounds.
     * @param _from address of the holder to transfer interest from
     * @param _to address of the holder to transfer interest to
     * @param _amount maximum amount of interest to transfer per round
     */
    function _transferInterest(address _from, address _to, uint256 _amount) internal {
        ClaimedRoyaltyInterest[MAX_ROYALTY_DISTRIBUTION_ROUNDS] storage fromInterest = _claimedRoyaltyInterest[_from];
        uint256 earliestRound = earliestRoyaltyDistributionRound();
        uint8 roundCount = royaltyDistributionRounds();
        for (uint256 i = 0; i < roundCount; i++) {
            uint256 round = earliestRound.add(i);
            uint8 index = _getRoyaltyRoundIndex(round);
            if (round != fromInterest[index].round) {
                // there is no source round or source round has expired so do nothing
                continue;
            }
            uint256 sourceAmount = fromInterest[index].amount;
            uint256 transferredAmount = _amount;
            if (transferredAmount > sourceAmount) {
                transferredAmount = sourceAmount;
            }
            uint256 targetAmount = 0;
            if (round == _claimedRoyaltyInterest[_to][index].round) {
                // source and target are the same round, update
                targetAmount = _claimedRoyaltyInterest[_to][index].amount;
            } else {
                // target is an old round, overwrite it
                _claimedRoyaltyInterest[_to][index].round = round;
            }
            fromInterest[index].amount = sourceAmount.sub(transferredAmount);
            _claimedRoyaltyInterest[_to][index].amount = targetAmount.add(transferredAmount);
            emit ClaimedRoyaltyInterestTransferred(_from, _to, round, transferredAmount);
        }
    }

    /**
     * @dev Overridden to apply canTrade modifier to function, validAddress modifier to destination address and
     *      claimed royalty interest transfer.
     */
    function transfer(address _to, uint256 _value) public canTrade validAddress(_to) returns (bool) {
        bool result = super.transfer(_to, _value);
        if (result) {
            _transferInterest(msg.sender, _to, _value);
        }
        return result;
    }

    /**
     * @dev Overridden to apply validAddress modifier to destination address and claimed royalty interest transfer.
     */
    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {
        bool result = super.transferFrom(_from, _to, _value);
        if (result) {
            _transferInterest(_from, _to, _value);
        }
        return result;
    }

    /**
     * @dev Overridden to apply canTrade modifier.
     */
    function approve(address _spender, uint256 _value) public canTrade returns (bool) {
        return super.approve(_spender, _value);
    }

    /**
     * @dev Overridden to apply canTrade modifier.
     */
    function increaseApproval(address _spender, uint _addedValue) public canTrade returns (bool) {
        return super.increaseApproval(_spender, _addedValue);
    }

    /**
     * @dev Overridden to apply canTrade modifier.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public canTrade returns (bool) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }
}

